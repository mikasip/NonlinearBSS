% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iVAE_spatial.R
\name{iVAE_spatial}
\alias{iVAE_spatial}
\title{Spatial Identifiable Variational Autoencoder}
\usage{
iVAE_spatial(
  data,
  locations,
  segment_sizes,
  joint_segment_inds = rep(1, length(segment_sizes)),
  latent_dim,
  test_inds = NULL,
  ...
)
}
\arguments{
\item{data}{A matrix with P columns and N rows containing the observed data.}

\item{locations}{A matrix with spatial locations.}

\item{segment_sizes}{A vector providing sizes for segments.
The dimension should match the spatial dimenstion.}

\item{joint_segment_inds}{A vector indicating which segments.
are considered jointly. See more in details.}

\item{latent_dim}{A latent dimension for iVAE.}

\item{test_inds}{A vector giving the indices of the data, which
are used as a test data.}

\item{...}{
  Arguments passed on to \code{\link[=iVAE]{iVAE}}
  \describe{
    \item{\code{hidden_units}}{K-dimensional vector giving the number of
hidden units for K layers in encoder and K layers in decoder.}
    \item{\code{aux_hidden_units}}{K-dimensional vector giving the number of
hidden units for K layers in auxiliary function.}
    \item{\code{validation_split}}{Proportion of data used for validation}
    \item{\code{activation}}{Activation function for the hidden layers.}
    \item{\code{source_dist}}{Distribution for the latent source.
Either "gaussian" or "laplace".}
    \item{\code{error_dist}}{Distribution for the model error.
Either "gaussian" or "laplace".}
    \item{\code{error_dist_sigma}}{A standard deviation for error_dist.}
    \item{\code{optimizer}}{A keras optimizer for the tensorflow model.
A default is Adam optimizer with polynomial decay.}
    \item{\code{lr_start}}{A starting learning rate for the default optimizer.}
    \item{\code{lr_end}}{A ending learning rate for the default optimizer.}
    \item{\code{steps}}{A number of learning steps between lr_start and lr_end
for the default optimizer.}
    \item{\code{seed}}{Seed for the tensorflow model. Should be used instead of
set.seed(seed).}
    \item{\code{get_prior_means}}{A boolean defining if the means provided by
the auxiliary function are returned.}
    \item{\code{true_data}}{The true latent components. If provided, the mean
correlation coefficient is calculated for each epoch.}
    \item{\code{epochs}}{A number of epochs for training.}
    \item{\code{batch_size}}{A batch size for training.}
  }}
}
\value{
An object of class iVAESpatial, inherits from class iVAE.
Additionally, the object has a property
\code{spatial_dim} which gives the dimension of the given locations.
For more details, see \code{\link{iVAE}}.
}
\description{
Trains an identifiable variational autoencoder (iVAE) using the input data
and the segmented spatial domain as auxiliary data.
}
\details{
The method creates the auxiliary data as spatial segments based on
the given input parameters.
The vector \code{segment_sizes} defines the size of the segments for
each spatial dimension separately. The segmentation is then created
based on the \code{joint_segment_inds}, which defines dimensions are
considered jointly. For example, \code{joint_segment_inds = c(1, 1)}
for two dimensional spatial data, defines that the dimensions are
considered jointly. This means that the auxiliary variable is vector
giving the two dimensional segment that the observations belongs in.
For \code{joint_segment_inds = c(1, 2)}, the auxiliary variable would
consist of two vectors, first giving one dimensional segment that
the observation belongs in the first spatial dimension, and the second
giving one dimensional segment that the observation belongs in the
secoun spatial dimension. All dimensions are considered jointly as
default.

After the segmentation, the method calls the function \code{iVAE}
using the created auxiliary variables.
}
\examples{
n <- 1000
coords <- matrix(runif(1000 * 2, 0, 1), ncol = 2)
p <- 3
# Generate artificial latent data
latent_data <- generate_nonstationary_spatial_data_by_segments(
    n,
    coords, 10
)$data
# Generate artificial observed data by applying a nonlinear mixture
obs_data <- mix_data(latent_data, 2)
cor(obs_data, latent_data)
resiVAE <- iVAE_spatial(obs_data, coords, c(0.1, 0.1), c(1, 1), 3,
    epochs = 300, batch_size = 64
)
cormat <- cor(resiVAE$IC, latent_data)
cormat
absolute_mean_correlation(cormat)

}
\references{
\insertAllCited{}
}
\seealso{
\code{\link{iVAE}}
\code{\link{generate_nonstationary_spatial_data_by_segments}}
}

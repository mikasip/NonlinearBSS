% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iVAE.R, R/iVAE_spatial.R
\name{iVAE_spatial}
\alias{iVAE_spatial}
\title{Trains an identifiable variational autoencoder (iVAE) using the input data
and the segmented spatial domain as auxiliary data.}
\usage{
iVAE_spatial(
  data,
  locations,
  segment_sizes,
  joint_segment_inds = rep(1, length(segment_sizes)),
  latent_dim,
  test_inds = NULL,
  epochs,
  batch_size,
  ...
)

iVAE_spatial(
  data,
  locations,
  segment_sizes,
  joint_segment_inds = rep(1, length(segment_sizes)),
  latent_dim,
  test_inds = NULL,
  epochs,
  batch_size,
  ...
)
}
\arguments{
\item{data}{A matrix with P columns and N rows containing the observed data.}

\item{locations}{A matrix with spatial locations.}

\item{segment_sizes}{A vector providing sizes for segments.
The dimension should match the spatial dimenstion.}

\item{joint_segment_inds}{A vector indicating which segments.
are considered jointly. See more in details.}

\item{latent_dim}{A latent dimension for iVAE.}

\item{test_inds}{A vector giving the indices of the data, which
are used as a test data.}

\item{epochs}{A number of epochs for iVAE training.}

\item{batch_size}{A batch size for iVAE training.}

\item{...}{Further parameters for \code{iVAE}.}
}
\value{
An object of class iVAESpatial, inherits from class iVAE.
Additionally, the object has a property
\code{spatial_dim} which gives the dimension of the given locations.
For more details, see [iVAE()].

An object of class iVAESpatial, inherits from class iVAE.
Additionally, the object has a property
\code{spatial_dim} which gives the dimension of the given locations.
For more details, see [iVAE()].
}
\description{
Trains an identifiable variational autoencoder (iVAE) using the input data
and the segmented spatial domain as auxiliary data.

Trains an identifiable variational autoencoder (iVAE) using the input data
and the segmented spatial domain as auxiliary data.
}
\details{
The method creates the auxiliary data as spatial segments based on
the given input parameters.
The vector \code{segment_sizes} defines the size of the segments for
each spatial dimension separately. The segmentation is then created
based on the \code{joint_segment_inds}, which defines dimensions are
considered jointly. For example, \code{joint_segment_inds = c(1, 1)}
for two dimensional spatial data, defines that the dimensions are
considered jointly. This means that the auxiliary variable is vector
giving the two dimensional segment that the observations belongs in.
For \code{joint_segment_inds = c(1, 2)}, the auxiliary variable would
consist of two vectors, first giving one dimensional segment that
the observation belongs in the first spatial dimension, and the second
giving one dimensional segment that the observation belongs in the
secoun spatial dimension. All dimensions are considered jointly as
default.

After the segmentation, the method calls the function \code{iVAE}
using the created auxiliary variables.

The method creates the auxiliary data as spatial segments based on
the given input parameters.
The vector \code{segment_sizes} defines the size of the segments for
each spatial dimension separately. The segmentation is then created
based on the \code{joint_segment_inds}, which defines dimensions are
considered jointly. For example, \code{joint_segment_inds = c(1, 1)}
for two dimensional spatial data, defines that the dimensions are
considered jointly. This means that the auxiliary variable is vector
giving the two dimensional segment that the observations belongs in.
For \code{joint_segment_inds = c(1, 2)}, the auxiliary variable would
consist of two vectors, first giving one dimensional segment that
the observation belongs in the first spatial dimension, and the second
giving one dimensional segment that the observation belongs in the
secoun spatial dimension. All dimensions are considered jointly as
default.

After the segmentation, the method calls the function \code{iVAE}
using the created auxiliary variables.
}
\examples{
# TODO
n <- 1000
coords <- matrix(runif(1000 * 2, 0, 1), ncol = 2)
p <- 3
# Generate artificial latent data
latent_data <- matrix(NA, nrow = n, ncol = p)
for (i in 1:p) {
    latent_data[, i] <-
        generate_nonstationary_spatial_data_by_segments(n, coords, 10)
}
# Generate artificial observed data by applying a nonlinear mixture
obs_data <- mix_data(latent_data, 3)
resiVAE <- iVAE_spatial(obs_data, coords, c(0.1, 0.1), c(1, 1), 3,
    epochs = 100, batch_size = 64
)
}
\references{
\insertAllCited{}

\insertAllCited{}
}
\seealso{
[iVAE()]

[iVAE()]
[generate_nonstationary_spatial_data_by_segments()]
}
